AWSTemplateFormatVersion: '2010-09-09'
Description: Product Infra Stack - S3 + CloudFront (OAC) + Lambda + DynamoDB + HTTP API + VPC

Parameters:
  BucketName:
    Type: String
    Default: product-static-bucket-eunorth1

Resources:

# -------------------------------
# VPC
# -------------------------------

  ProductVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: ProductVPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway

  AttachIGW:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref ProductVPC
      InternetGatewayId: !Ref InternetGateway


  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProductVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: ProductPublicSubnet1


  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProductVPC
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: ProductPublicSubnet2


  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProductVPC
      Tags:
        - Key: Name
          Value: ProductPublicRouteTable


  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachIGW
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway


  PublicSubnet1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable


  PublicSubnet2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

# -------------------------------
# S3 Bucket (Private)
# -------------------------------

  StaticBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

# -------------------------------
# CloudFront OAC
# -------------------------------

  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: ProductOAC
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt StaticBucket.RegionalDomainName
            S3OriginConfig: {}
            OriginAccessControlId: !Ref CloudFrontOAC
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD]
          CachedMethods: [GET, HEAD]
          ForwardedValues:
            QueryString: false
        ViewerCertificate:
          CloudFrontDefaultCertificate: true

  BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref StaticBucket
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub "${StaticBucket.Arn}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}"

# -------------------------------
# DynamoDB
# -------------------------------

  ProductTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Product
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: productId
          AttributeType: S
      KeySchema:
        - AttributeName: productId
          KeyType: HASH

# -------------------------------
# IAM Role for Lambda
# -------------------------------

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ProductLambdaRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: DynamoAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                Resource: !GetAtt ProductTable.Arn
              - Effect: Allow
                Action:
                  - logs:*
                Resource: "*"

# -------------------------------
# Lambda Function
# -------------------------------

  ProductFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ProductFunction
      Runtime: nodejs20.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 10
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamo = new AWS.DynamoDB.DocumentClient();
          const TABLE = process.env.TABLE_NAME;

          exports.handler = async (event) => {
              const method = event.requestContext.http.method;
              const body = event.body ? JSON.parse(event.body) : null;
              const id = event.pathParameters ? event.pathParameters.id : null;

              try {
                  if (method === "GET") {
                      const data = await dynamo.scan({ TableName: TABLE }).promise();
                      return { statusCode: 200, body: JSON.stringify(data.Items) };
                  }

                  if (method === "POST") {
                      await dynamo.put({ TableName: TABLE, Item: body }).promise();
                      return { statusCode: 201, body: JSON.stringify(body) };
                  }

                  if (method === "PUT") {
                      await dynamo.put({ TableName: TABLE, Item: body }).promise();
                      return { statusCode: 200, body: JSON.stringify(body) };
                  }

                  if (method === "DELETE") {
                      await dynamo.delete({
                          TableName: TABLE,
                          Key: { productId: id }
                      }).promise();
                      return { statusCode: 200, body: "Deleted" };
                  }

                  return { statusCode: 400, body: "Invalid Method" };

              } catch (err) {
                  return { statusCode: 500, body: err.message };
              }
          };
      Environment:
        Variables:
          TABLE_NAME: !Ref ProductTable

# -------------------------------
# HTTP API Gateway
# -------------------------------

  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: ProductHttpApi
      ProtocolType: HTTP

  LambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt ProductFunction.Arn
      PayloadFormatVersion: "2.0"

  ApiRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: ANY /product/{id}
      Target: !Sub "integrations/${LambdaIntegration}"

  ApiRouteNoId:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: ANY /product
      Target: !Sub "integrations/${LambdaIntegration}"

  Stage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: prod
      AutoDeploy: true

  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProductFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com

Outputs:
  CloudFrontURL:
    Value: !Sub "https://${CloudFrontDistribution.DomainName}"

  ApiEndpoint:
    Value: !Sub "${HttpApi.ApiEndpoint}/prod"
